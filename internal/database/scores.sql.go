// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: scores.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createScore = `-- name: CreateScore :one
insert into scores (
    score_id,
    beatmap_id,
    song_id,
    user_id,
    accuracy,
    max_combo,
    dx_score,
    played_at,
    created_at
)
values ($1, $2, $3, $4, $5, $6, $7, $8, now())
returning score_id, beatmap_id, song_id, user_id, accuracy, max_combo, dx_score, played_at, created_at
`

type CreateScoreParams struct {
	ScoreID   uuid.UUID
	BeatmapID uuid.UUID
	SongID    uuid.UUID
	UserID    uuid.UUID
	Accuracy  string
	MaxCombo  int32
	DxScore   int32
	PlayedAt  pgtype.Timestamp
}

func (q *Queries) CreateScore(ctx context.Context, arg CreateScoreParams) (Score, error) {
	row := q.db.QueryRow(ctx, createScore,
		arg.ScoreID,
		arg.BeatmapID,
		arg.SongID,
		arg.UserID,
		arg.Accuracy,
		arg.MaxCombo,
		arg.DxScore,
		arg.PlayedAt,
	)
	var i Score
	err := row.Scan(
		&i.ScoreID,
		&i.BeatmapID,
		&i.SongID,
		&i.UserID,
		&i.Accuracy,
		&i.MaxCombo,
		&i.DxScore,
		&i.PlayedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getAllScores = `-- name: GetAllScores :many
select
    score_id,
    beatmap_id,
    song_id,
    user_id,
    accuracy,
    max_combo,
    dx_score,
    played_at,
    created_at
from scores
`

func (q *Queries) GetAllScores(ctx context.Context) ([]Score, error) {
	rows, err := q.db.Query(ctx, getAllScores)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Score
	for rows.Next() {
		var i Score
		if err := rows.Scan(
			&i.ScoreID,
			&i.BeatmapID,
			&i.SongID,
			&i.UserID,
			&i.Accuracy,
			&i.MaxCombo,
			&i.DxScore,
			&i.PlayedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScoreByUserID = `-- name: GetScoreByUserID :one
select
    score_id,
    beatmap_id,
    song_id,
    user_id,
    accuracy,
    max_combo,
    dx_score,
    played_at,
    created_at
from scores
where user_id = $1
`

func (q *Queries) GetScoreByUserID(ctx context.Context, userID uuid.UUID) (Score, error) {
	row := q.db.QueryRow(ctx, getScoreByUserID, userID)
	var i Score
	err := row.Scan(
		&i.ScoreID,
		&i.BeatmapID,
		&i.SongID,
		&i.UserID,
		&i.Accuracy,
		&i.MaxCombo,
		&i.DxScore,
		&i.PlayedAt,
		&i.CreatedAt,
	)
	return i, err
}
