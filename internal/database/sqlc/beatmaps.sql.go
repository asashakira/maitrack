// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: beatmaps.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createBeatmap = `-- name: CreateBeatmap :one
insert into beatmaps (
    beatmap_id,
    song_id,
    difficulty,
    level,
    internal_level,
    type,
    total_notes,
    tap,
    hold,
    slide,
    touch,
    break,
    note_designer,
    max_dx_score,
    updated_at,
    created_at
)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, now(), now())
returning
    beatmap_id,
    song_id,
    difficulty,
    level,
    internal_level,
    type,
    total_notes,
    tap,
    hold,
    slide,
    touch,
    break,
    note_designer,
    max_dx_score,
    updated_at,
    created_at
`

type CreateBeatmapParams struct {
	BeatmapID     uuid.UUID      `json:"beatmapID"`
	SongID        uuid.UUID      `json:"songID"`
	Difficulty    string         `json:"difficulty"`
	Level         string         `json:"level"`
	InternalLevel pgtype.Numeric `json:"internalLevel"`
	Type          string         `json:"type"`
	TotalNotes    int32          `json:"totalNotes"`
	Tap           int32          `json:"tap"`
	Hold          int32          `json:"hold"`
	Slide         int32          `json:"slide"`
	Touch         int32          `json:"touch"`
	Break         int32          `json:"break"`
	NoteDesigner  string         `json:"noteDesigner"`
	MaxDxScore    int32          `json:"maxDxScore"`
}

func (q *Queries) CreateBeatmap(ctx context.Context, arg CreateBeatmapParams) (Beatmap, error) {
	row := q.db.QueryRow(ctx, createBeatmap,
		arg.BeatmapID,
		arg.SongID,
		arg.Difficulty,
		arg.Level,
		arg.InternalLevel,
		arg.Type,
		arg.TotalNotes,
		arg.Tap,
		arg.Hold,
		arg.Slide,
		arg.Touch,
		arg.Break,
		arg.NoteDesigner,
		arg.MaxDxScore,
	)
	var i Beatmap
	err := row.Scan(
		&i.BeatmapID,
		&i.SongID,
		&i.Difficulty,
		&i.Level,
		&i.InternalLevel,
		&i.Type,
		&i.TotalNotes,
		&i.Tap,
		&i.Hold,
		&i.Slide,
		&i.Touch,
		&i.Break,
		&i.NoteDesigner,
		&i.MaxDxScore,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getAllBeatmaps = `-- name: GetAllBeatmaps :many
select
    beatmaps.beatmap_id,
    beatmaps.song_id,
    beatmaps.difficulty,
    beatmaps.level,
    beatmaps.internal_level,
    beatmaps.type,
    beatmaps.total_notes,
    beatmaps.tap,
    beatmaps.hold,
    beatmaps.slide,
    beatmaps.touch,
    beatmaps.break,
    beatmaps.note_designer,
    beatmaps.max_dx_score,
    songs.title,
    songs.artist,
    songs.genre,
    songs.bpm,
    songs.image_url,
    songs.version
from beatmaps
inner join songs on beatmaps.song_id = songs.song_id
`

type GetAllBeatmapsRow struct {
	BeatmapID     uuid.UUID      `json:"beatmapID"`
	SongID        uuid.UUID      `json:"songID"`
	Difficulty    string         `json:"difficulty"`
	Level         string         `json:"level"`
	InternalLevel pgtype.Numeric `json:"internalLevel"`
	Type          string         `json:"type"`
	TotalNotes    int32          `json:"totalNotes"`
	Tap           int32          `json:"tap"`
	Hold          int32          `json:"hold"`
	Slide         int32          `json:"slide"`
	Touch         int32          `json:"touch"`
	Break         int32          `json:"break"`
	NoteDesigner  string         `json:"noteDesigner"`
	MaxDxScore    int32          `json:"maxDxScore"`
	Title         string         `json:"title"`
	Artist        string         `json:"artist"`
	Genre         string         `json:"genre"`
	Bpm           string         `json:"bpm"`
	ImageUrl      string         `json:"imageUrl"`
	Version       string         `json:"version"`
}

func (q *Queries) GetAllBeatmaps(ctx context.Context) ([]GetAllBeatmapsRow, error) {
	rows, err := q.db.Query(ctx, getAllBeatmaps)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllBeatmapsRow
	for rows.Next() {
		var i GetAllBeatmapsRow
		if err := rows.Scan(
			&i.BeatmapID,
			&i.SongID,
			&i.Difficulty,
			&i.Level,
			&i.InternalLevel,
			&i.Type,
			&i.TotalNotes,
			&i.Tap,
			&i.Hold,
			&i.Slide,
			&i.Touch,
			&i.Break,
			&i.NoteDesigner,
			&i.MaxDxScore,
			&i.Title,
			&i.Artist,
			&i.Genre,
			&i.Bpm,
			&i.ImageUrl,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBeatmapByBeatmapID = `-- name: GetBeatmapByBeatmapID :one
select
    beatmaps.beatmap_id,
    beatmaps.song_id,
    beatmaps.difficulty,
    beatmaps.level,
    beatmaps.internal_level,
    beatmaps.type,
    beatmaps.total_notes,
    beatmaps.tap,
    beatmaps.hold,
    beatmaps.slide,
    beatmaps.touch,
    beatmaps.break,
    beatmaps.note_designer,
    beatmaps.max_dx_score,
    songs.title,
    songs.artist,
    songs.genre,
    songs.bpm,
    songs.image_url,
    songs.version
from beatmaps
inner join songs on beatmaps.song_id = songs.song_id
where beatmaps.beatmap_id = $1
`

type GetBeatmapByBeatmapIDRow struct {
	BeatmapID     uuid.UUID      `json:"beatmapID"`
	SongID        uuid.UUID      `json:"songID"`
	Difficulty    string         `json:"difficulty"`
	Level         string         `json:"level"`
	InternalLevel pgtype.Numeric `json:"internalLevel"`
	Type          string         `json:"type"`
	TotalNotes    int32          `json:"totalNotes"`
	Tap           int32          `json:"tap"`
	Hold          int32          `json:"hold"`
	Slide         int32          `json:"slide"`
	Touch         int32          `json:"touch"`
	Break         int32          `json:"break"`
	NoteDesigner  string         `json:"noteDesigner"`
	MaxDxScore    int32          `json:"maxDxScore"`
	Title         string         `json:"title"`
	Artist        string         `json:"artist"`
	Genre         string         `json:"genre"`
	Bpm           string         `json:"bpm"`
	ImageUrl      string         `json:"imageUrl"`
	Version       string         `json:"version"`
}

func (q *Queries) GetBeatmapByBeatmapID(ctx context.Context, beatmapID uuid.UUID) (GetBeatmapByBeatmapIDRow, error) {
	row := q.db.QueryRow(ctx, getBeatmapByBeatmapID, beatmapID)
	var i GetBeatmapByBeatmapIDRow
	err := row.Scan(
		&i.BeatmapID,
		&i.SongID,
		&i.Difficulty,
		&i.Level,
		&i.InternalLevel,
		&i.Type,
		&i.TotalNotes,
		&i.Tap,
		&i.Hold,
		&i.Slide,
		&i.Touch,
		&i.Break,
		&i.NoteDesigner,
		&i.MaxDxScore,
		&i.Title,
		&i.Artist,
		&i.Genre,
		&i.Bpm,
		&i.ImageUrl,
		&i.Version,
	)
	return i, err
}

const getBeatmapBySongIDDifficultyAndType = `-- name: GetBeatmapBySongIDDifficultyAndType :one
select beatmap_id, song_id, difficulty, level, internal_level, type, total_notes, tap, hold, slide, touch, break, note_designer, max_dx_score, updated_at, created_at
from beatmaps
where song_id = $1 and difficulty = $2 and type = $3
`

type GetBeatmapBySongIDDifficultyAndTypeParams struct {
	SongID     uuid.UUID `json:"songID"`
	Difficulty string    `json:"difficulty"`
	Type       string    `json:"type"`
}

func (q *Queries) GetBeatmapBySongIDDifficultyAndType(ctx context.Context, arg GetBeatmapBySongIDDifficultyAndTypeParams) (Beatmap, error) {
	row := q.db.QueryRow(ctx, getBeatmapBySongIDDifficultyAndType, arg.SongID, arg.Difficulty, arg.Type)
	var i Beatmap
	err := row.Scan(
		&i.BeatmapID,
		&i.SongID,
		&i.Difficulty,
		&i.Level,
		&i.InternalLevel,
		&i.Type,
		&i.TotalNotes,
		&i.Tap,
		&i.Hold,
		&i.Slide,
		&i.Touch,
		&i.Break,
		&i.NoteDesigner,
		&i.MaxDxScore,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getBeatmapsBySongID = `-- name: GetBeatmapsBySongID :many
select
    beatmaps.beatmap_id,
    beatmaps.song_id,
    beatmaps.difficulty,
    beatmaps.level,
    beatmaps.internal_level,
    beatmaps.type,
    beatmaps.total_notes,
    beatmaps.tap,
    beatmaps.hold,
    beatmaps.slide,
    beatmaps.touch,
    beatmaps.break,
    beatmaps.note_designer,
    beatmaps.max_dx_score,
    songs.title,
    songs.artist,
    songs.genre,
    songs.bpm,
    songs.image_url,
    songs.version
from beatmaps
inner join songs on beatmaps.song_id = songs.song_id
where beatmaps.song_id = $1
`

type GetBeatmapsBySongIDRow struct {
	BeatmapID     uuid.UUID      `json:"beatmapID"`
	SongID        uuid.UUID      `json:"songID"`
	Difficulty    string         `json:"difficulty"`
	Level         string         `json:"level"`
	InternalLevel pgtype.Numeric `json:"internalLevel"`
	Type          string         `json:"type"`
	TotalNotes    int32          `json:"totalNotes"`
	Tap           int32          `json:"tap"`
	Hold          int32          `json:"hold"`
	Slide         int32          `json:"slide"`
	Touch         int32          `json:"touch"`
	Break         int32          `json:"break"`
	NoteDesigner  string         `json:"noteDesigner"`
	MaxDxScore    int32          `json:"maxDxScore"`
	Title         string         `json:"title"`
	Artist        string         `json:"artist"`
	Genre         string         `json:"genre"`
	Bpm           string         `json:"bpm"`
	ImageUrl      string         `json:"imageUrl"`
	Version       string         `json:"version"`
}

func (q *Queries) GetBeatmapsBySongID(ctx context.Context, songID uuid.UUID) ([]GetBeatmapsBySongIDRow, error) {
	rows, err := q.db.Query(ctx, getBeatmapsBySongID, songID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBeatmapsBySongIDRow
	for rows.Next() {
		var i GetBeatmapsBySongIDRow
		if err := rows.Scan(
			&i.BeatmapID,
			&i.SongID,
			&i.Difficulty,
			&i.Level,
			&i.InternalLevel,
			&i.Type,
			&i.TotalNotes,
			&i.Tap,
			&i.Hold,
			&i.Slide,
			&i.Touch,
			&i.Break,
			&i.NoteDesigner,
			&i.MaxDxScore,
			&i.Title,
			&i.Artist,
			&i.Genre,
			&i.Bpm,
			&i.ImageUrl,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBeatmap = `-- name: UpdateBeatmap :one
update beatmaps
set
    song_id = $2,
    difficulty = $3,
    level = $4,
    internal_level = $5,
    type = $6,
    total_notes = $7,
    tap = $8,
    hold = $9,
    slide = $10,
    touch = $11,
    break = $12,
    note_designer = $13,
    max_dx_score = $14,
    updated_at = now()
where beatmap_id = $1
returning beatmap_id, song_id, difficulty, level, internal_level, type, total_notes, tap, hold, slide, touch, break, note_designer, max_dx_score, updated_at, created_at
`

type UpdateBeatmapParams struct {
	BeatmapID     uuid.UUID      `json:"beatmapID"`
	SongID        uuid.UUID      `json:"songID"`
	Difficulty    string         `json:"difficulty"`
	Level         string         `json:"level"`
	InternalLevel pgtype.Numeric `json:"internalLevel"`
	Type          string         `json:"type"`
	TotalNotes    int32          `json:"totalNotes"`
	Tap           int32          `json:"tap"`
	Hold          int32          `json:"hold"`
	Slide         int32          `json:"slide"`
	Touch         int32          `json:"touch"`
	Break         int32          `json:"break"`
	NoteDesigner  string         `json:"noteDesigner"`
	MaxDxScore    int32          `json:"maxDxScore"`
}

func (q *Queries) UpdateBeatmap(ctx context.Context, arg UpdateBeatmapParams) (Beatmap, error) {
	row := q.db.QueryRow(ctx, updateBeatmap,
		arg.BeatmapID,
		arg.SongID,
		arg.Difficulty,
		arg.Level,
		arg.InternalLevel,
		arg.Type,
		arg.TotalNotes,
		arg.Tap,
		arg.Hold,
		arg.Slide,
		arg.Touch,
		arg.Break,
		arg.NoteDesigner,
		arg.MaxDxScore,
	)
	var i Beatmap
	err := row.Scan(
		&i.BeatmapID,
		&i.SongID,
		&i.Difficulty,
		&i.Level,
		&i.InternalLevel,
		&i.Type,
		&i.TotalNotes,
		&i.Tap,
		&i.Hold,
		&i.Slide,
		&i.Touch,
		&i.Break,
		&i.NoteDesigner,
		&i.MaxDxScore,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
