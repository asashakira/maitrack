// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: beatmaps.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createBeatmap = `-- name: CreateBeatmap :one
insert into beatmaps (
    beatmap_id,
    song_id,
    difficulty,
    level,
    internal_level,
    type,
    total_notes,
    tap,
    hold,
    slide,
    touch,
    break,
    note_designer,
    max_dx_score,
    updated_at,
    created_at
)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, now(), now())
returning
    beatmap_id,
    song_id,
    difficulty,
    level,
    internal_level,
    type,
    total_notes,
    tap,
    hold,
    slide,
    touch,
    break,
    note_designer,
    max_dx_score,
    updated_at,
    created_at
`

type CreateBeatmapParams struct {
	BeatmapID     uuid.UUID
	SongID        uuid.UUID
	Difficulty    string
	Level         string
	InternalLevel pgtype.Numeric
	Type          string
	TotalNotes    int32
	Tap           int32
	Hold          int32
	Slide         int32
	Touch         int32
	Break         int32
	NoteDesigner  string
	MaxDxScore    int32
}

func (q *Queries) CreateBeatmap(ctx context.Context, arg CreateBeatmapParams) (Beatmap, error) {
	row := q.db.QueryRow(ctx, createBeatmap,
		arg.BeatmapID,
		arg.SongID,
		arg.Difficulty,
		arg.Level,
		arg.InternalLevel,
		arg.Type,
		arg.TotalNotes,
		arg.Tap,
		arg.Hold,
		arg.Slide,
		arg.Touch,
		arg.Break,
		arg.NoteDesigner,
		arg.MaxDxScore,
	)
	var i Beatmap
	err := row.Scan(
		&i.BeatmapID,
		&i.SongID,
		&i.Difficulty,
		&i.Level,
		&i.InternalLevel,
		&i.Type,
		&i.TotalNotes,
		&i.Tap,
		&i.Hold,
		&i.Slide,
		&i.Touch,
		&i.Break,
		&i.NoteDesigner,
		&i.MaxDxScore,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getAllBeatmaps = `-- name: GetAllBeatmaps :many
select
    beatmap_id,
    song_id,
    difficulty,
    level,
    internal_level,
    type,
    total_notes,
    tap,
    hold,
    slide,
    touch,
    break,
    note_designer,
    max_dx_score,
    updated_at,
    created_at
from beatmaps
`

func (q *Queries) GetAllBeatmaps(ctx context.Context) ([]Beatmap, error) {
	rows, err := q.db.Query(ctx, getAllBeatmaps)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Beatmap
	for rows.Next() {
		var i Beatmap
		if err := rows.Scan(
			&i.BeatmapID,
			&i.SongID,
			&i.Difficulty,
			&i.Level,
			&i.InternalLevel,
			&i.Type,
			&i.TotalNotes,
			&i.Tap,
			&i.Hold,
			&i.Slide,
			&i.Touch,
			&i.Break,
			&i.NoteDesigner,
			&i.MaxDxScore,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBeatmapByBeatmapID = `-- name: GetBeatmapByBeatmapID :one
select
    beatmap_id,
    song_id,
    difficulty,
    level,
    internal_level,
    type,
    total_notes,
    tap,
    hold,
    slide,
    touch,
    break,
    note_designer,
    max_dx_score,
    updated_at,
    created_at
from beatmaps
where beatmap_id = $1
`

func (q *Queries) GetBeatmapByBeatmapID(ctx context.Context, beatmapID uuid.UUID) (Beatmap, error) {
	row := q.db.QueryRow(ctx, getBeatmapByBeatmapID, beatmapID)
	var i Beatmap
	err := row.Scan(
		&i.BeatmapID,
		&i.SongID,
		&i.Difficulty,
		&i.Level,
		&i.InternalLevel,
		&i.Type,
		&i.TotalNotes,
		&i.Tap,
		&i.Hold,
		&i.Slide,
		&i.Touch,
		&i.Break,
		&i.NoteDesigner,
		&i.MaxDxScore,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getBeatmapBySongIDDifficultyAndType = `-- name: GetBeatmapBySongIDDifficultyAndType :one
select
    beatmap_id,
    song_id,
    difficulty,
    level,
    internal_level,
    type,
    total_notes,
    tap,
    hold,
    slide,
    touch,
    break,
    note_designer,
    max_dx_score,
    updated_at,
    created_at
from beatmaps
where song_id = $1 and difficulty = $2 and type = $3
`

type GetBeatmapBySongIDDifficultyAndTypeParams struct {
	SongID     uuid.UUID
	Difficulty string
	Type       string
}

func (q *Queries) GetBeatmapBySongIDDifficultyAndType(ctx context.Context, arg GetBeatmapBySongIDDifficultyAndTypeParams) (Beatmap, error) {
	row := q.db.QueryRow(ctx, getBeatmapBySongIDDifficultyAndType, arg.SongID, arg.Difficulty, arg.Type)
	var i Beatmap
	err := row.Scan(
		&i.BeatmapID,
		&i.SongID,
		&i.Difficulty,
		&i.Level,
		&i.InternalLevel,
		&i.Type,
		&i.TotalNotes,
		&i.Tap,
		&i.Hold,
		&i.Slide,
		&i.Touch,
		&i.Break,
		&i.NoteDesigner,
		&i.MaxDxScore,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getBeatmapsBySongID = `-- name: GetBeatmapsBySongID :many
select
    beatmap_id,
    song_id,
    difficulty,
    level,
    internal_level,
    type,
    total_notes,
    tap,
    hold,
    slide,
    touch,
    break,
    note_designer,
    max_dx_score,
    updated_at,
    created_at
from beatmaps
where song_id = $1
`

func (q *Queries) GetBeatmapsBySongID(ctx context.Context, songID uuid.UUID) ([]Beatmap, error) {
	rows, err := q.db.Query(ctx, getBeatmapsBySongID, songID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Beatmap
	for rows.Next() {
		var i Beatmap
		if err := rows.Scan(
			&i.BeatmapID,
			&i.SongID,
			&i.Difficulty,
			&i.Level,
			&i.InternalLevel,
			&i.Type,
			&i.TotalNotes,
			&i.Tap,
			&i.Hold,
			&i.Slide,
			&i.Touch,
			&i.Break,
			&i.NoteDesigner,
			&i.MaxDxScore,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBeatmap = `-- name: UpdateBeatmap :one
update beatmaps
set
    song_id = $2,
    difficulty = $3,
    level = $4,
    internal_level = $5,
    type = $6,
    total_notes = $7,
    tap = $8,
    hold = $9,
    slide = $10,
    touch = $11,
    break = $12,
    note_designer = $13,
    max_dx_score = $14,
    updated_at = now()
where beatmap_id = $1
returning
    beatmap_id,
    song_id,
    difficulty,
    level,
    internal_level,
    type,
    total_notes,
    tap,
    hold,
    slide,
    touch,
    break,
    note_designer,
    max_dx_score,
    updated_at,
    created_at
`

type UpdateBeatmapParams struct {
	BeatmapID     uuid.UUID
	SongID        uuid.UUID
	Difficulty    string
	Level         string
	InternalLevel pgtype.Numeric
	Type          string
	TotalNotes    int32
	Tap           int32
	Hold          int32
	Slide         int32
	Touch         int32
	Break         int32
	NoteDesigner  string
	MaxDxScore    int32
}

func (q *Queries) UpdateBeatmap(ctx context.Context, arg UpdateBeatmapParams) (Beatmap, error) {
	row := q.db.QueryRow(ctx, updateBeatmap,
		arg.BeatmapID,
		arg.SongID,
		arg.Difficulty,
		arg.Level,
		arg.InternalLevel,
		arg.Type,
		arg.TotalNotes,
		arg.Tap,
		arg.Hold,
		arg.Slide,
		arg.Touch,
		arg.Break,
		arg.NoteDesigner,
		arg.MaxDxScore,
	)
	var i Beatmap
	err := row.Scan(
		&i.BeatmapID,
		&i.SongID,
		&i.Difficulty,
		&i.Level,
		&i.InternalLevel,
		&i.Type,
		&i.TotalNotes,
		&i.Tap,
		&i.Hold,
		&i.Slide,
		&i.Touch,
		&i.Break,
		&i.NoteDesigner,
		&i.MaxDxScore,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
