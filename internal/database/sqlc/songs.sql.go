// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: songs.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createSong = `-- name: CreateSong :one
insert into songs (
    song_id,
    alt_key,
    title,
    artist,
    genre,
    bpm,
    image_url,
    version,
    is_utage,
    is_available,
    release_date,
    delete_date,
    updated_at,
    created_at
)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, now(), now())
returning
    song_id,
    alt_key,
    title,
    artist,
    genre,
    bpm,
    image_url,
    version,
    is_utage,
    is_available,
    release_date,
    delete_date,
    updated_at,
    created_at
`

type CreateSongParams struct {
	SongID      uuid.UUID
	AltKey      string
	Title       string
	Artist      string
	Genre       string
	Bpm         string
	ImageUrl    string
	Version     string
	IsUtage     bool
	IsAvailable bool
	ReleaseDate pgtype.Date
	DeleteDate  pgtype.Date
}

func (q *Queries) CreateSong(ctx context.Context, arg CreateSongParams) (Song, error) {
	row := q.db.QueryRow(ctx, createSong,
		arg.SongID,
		arg.AltKey,
		arg.Title,
		arg.Artist,
		arg.Genre,
		arg.Bpm,
		arg.ImageUrl,
		arg.Version,
		arg.IsUtage,
		arg.IsAvailable,
		arg.ReleaseDate,
		arg.DeleteDate,
	)
	var i Song
	err := row.Scan(
		&i.SongID,
		&i.AltKey,
		&i.Title,
		&i.Artist,
		&i.Genre,
		&i.Bpm,
		&i.ImageUrl,
		&i.Version,
		&i.IsUtage,
		&i.IsAvailable,
		&i.ReleaseDate,
		&i.DeleteDate,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getAllSongs = `-- name: GetAllSongs :many
select
    song_id,
    alt_key,
    title,
    artist,
    genre,
    bpm,
    image_url,
    version,
    is_utage,
    is_available,
    release_date,
    delete_date,
    updated_at,
    created_at
from songs
`

func (q *Queries) GetAllSongs(ctx context.Context) ([]Song, error) {
	rows, err := q.db.Query(ctx, getAllSongs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Song
	for rows.Next() {
		var i Song
		if err := rows.Scan(
			&i.SongID,
			&i.AltKey,
			&i.Title,
			&i.Artist,
			&i.Genre,
			&i.Bpm,
			&i.ImageUrl,
			&i.Version,
			&i.IsUtage,
			&i.IsAvailable,
			&i.ReleaseDate,
			&i.DeleteDate,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSongByAltKey = `-- name: GetSongByAltKey :one
select
    song_id,
    alt_key,
    title,
    artist,
    genre,
    bpm,
    image_url,
    version,
    is_utage,
    is_available,
    release_date,
    delete_date,
    updated_at,
    created_at
from songs
where alt_key = $1
`

func (q *Queries) GetSongByAltKey(ctx context.Context, altKey string) (Song, error) {
	row := q.db.QueryRow(ctx, getSongByAltKey, altKey)
	var i Song
	err := row.Scan(
		&i.SongID,
		&i.AltKey,
		&i.Title,
		&i.Artist,
		&i.Genre,
		&i.Bpm,
		&i.ImageUrl,
		&i.Version,
		&i.IsUtage,
		&i.IsAvailable,
		&i.ReleaseDate,
		&i.DeleteDate,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSongBySongID = `-- name: GetSongBySongID :one
select
    song_id,
    alt_key,
    title,
    artist,
    genre,
    bpm,
    image_url,
    version,
    is_utage,
    is_available,
    release_date,
    delete_date,
    updated_at,
    created_at
from songs
where song_id = $1
`

func (q *Queries) GetSongBySongID(ctx context.Context, songID uuid.UUID) (Song, error) {
	row := q.db.QueryRow(ctx, getSongBySongID, songID)
	var i Song
	err := row.Scan(
		&i.SongID,
		&i.AltKey,
		&i.Title,
		&i.Artist,
		&i.Genre,
		&i.Bpm,
		&i.ImageUrl,
		&i.Version,
		&i.IsUtage,
		&i.IsAvailable,
		&i.ReleaseDate,
		&i.DeleteDate,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSongByTitleAndArtist = `-- name: GetSongByTitleAndArtist :one
select
    song_id,
    alt_key,
    title,
    artist,
    genre,
    bpm,
    image_url,
    version,
    is_utage,
    is_available,
    release_date,
    delete_date,
    updated_at,
    created_at
from songs
where title = $1 and artist = $2
`

type GetSongByTitleAndArtistParams struct {
	Title  string
	Artist string
}

func (q *Queries) GetSongByTitleAndArtist(ctx context.Context, arg GetSongByTitleAndArtistParams) (Song, error) {
	row := q.db.QueryRow(ctx, getSongByTitleAndArtist, arg.Title, arg.Artist)
	var i Song
	err := row.Scan(
		&i.SongID,
		&i.AltKey,
		&i.Title,
		&i.Artist,
		&i.Genre,
		&i.Bpm,
		&i.ImageUrl,
		&i.Version,
		&i.IsUtage,
		&i.IsAvailable,
		&i.ReleaseDate,
		&i.DeleteDate,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSongsByTitle = `-- name: GetSongsByTitle :many
select
    song_id,
    alt_key,
    title,
    artist,
    genre,
    bpm,
    image_url,
    version,
    is_utage,
    is_available,
    release_date,
    delete_date,
    updated_at,
    created_at
from songs
where title = $1
`

func (q *Queries) GetSongsByTitle(ctx context.Context, title string) ([]Song, error) {
	rows, err := q.db.Query(ctx, getSongsByTitle, title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Song
	for rows.Next() {
		var i Song
		if err := rows.Scan(
			&i.SongID,
			&i.AltKey,
			&i.Title,
			&i.Artist,
			&i.Genre,
			&i.Bpm,
			&i.ImageUrl,
			&i.Version,
			&i.IsUtage,
			&i.IsAvailable,
			&i.ReleaseDate,
			&i.DeleteDate,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSong = `-- name: UpdateSong :one
update songs
set
    alt_key = $2,
    title = $1,
    artist = $3,
    genre = $4,
    bpm = $5,
    image_url = $6,
    version = $7,
    is_utage = $8,
    is_available = $9,
    release_date = $10,
    delete_date = $11,
    updated_at = now()
where song_id = $12
returning
    song_id,
    alt_key,
    title,
    artist,
    genre,
    bpm,
    image_url,
    version,
    is_utage,
    is_available,
    release_date,
    delete_date,
    updated_at,
    created_at
`

type UpdateSongParams struct {
	Title       string
	AltKey      string
	Artist      string
	Genre       string
	Bpm         string
	ImageUrl    string
	Version     string
	IsUtage     bool
	IsAvailable bool
	ReleaseDate pgtype.Date
	DeleteDate  pgtype.Date
	SongID      uuid.UUID
}

func (q *Queries) UpdateSong(ctx context.Context, arg UpdateSongParams) (Song, error) {
	row := q.db.QueryRow(ctx, updateSong,
		arg.Title,
		arg.AltKey,
		arg.Artist,
		arg.Genre,
		arg.Bpm,
		arg.ImageUrl,
		arg.Version,
		arg.IsUtage,
		arg.IsAvailable,
		arg.ReleaseDate,
		arg.DeleteDate,
		arg.SongID,
	)
	var i Song
	err := row.Scan(
		&i.SongID,
		&i.AltKey,
		&i.Title,
		&i.Artist,
		&i.Genre,
		&i.Bpm,
		&i.ImageUrl,
		&i.Version,
		&i.IsUtage,
		&i.IsAvailable,
		&i.ReleaseDate,
		&i.DeleteDate,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
