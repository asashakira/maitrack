// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: songs.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createSong = `-- name: CreateSong :one
insert into songs (
    song_id,
    alt_key,
    title,
    artist,
    genre,
    bpm,
    image_url,
    version,
    is_utage,
    is_available,
    release_date,
    delete_date,
    updated_at,
    created_at
)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, now(), now())
returning
    song_id,
    alt_key,
    title,
    artist,
    genre,
    bpm,
    image_url,
    version,
    is_utage,
    is_available,
    release_date,
    delete_date,
    updated_at,
    created_at
`

type CreateSongParams struct {
	SongID      uuid.UUID   `json:"songID"`
	AltKey      string      `json:"altKey"`
	Title       string      `json:"title"`
	Artist      string      `json:"artist"`
	Genre       string      `json:"genre"`
	Bpm         string      `json:"bpm"`
	ImageUrl    string      `json:"imageUrl"`
	Version     string      `json:"version"`
	IsUtage     bool        `json:"isUtage"`
	IsAvailable bool        `json:"isAvailable"`
	ReleaseDate pgtype.Date `json:"releaseDate"`
	DeleteDate  pgtype.Date `json:"deleteDate"`
}

func (q *Queries) CreateSong(ctx context.Context, arg CreateSongParams) (Song, error) {
	row := q.db.QueryRow(ctx, createSong,
		arg.SongID,
		arg.AltKey,
		arg.Title,
		arg.Artist,
		arg.Genre,
		arg.Bpm,
		arg.ImageUrl,
		arg.Version,
		arg.IsUtage,
		arg.IsAvailable,
		arg.ReleaseDate,
		arg.DeleteDate,
	)
	var i Song
	err := row.Scan(
		&i.SongID,
		&i.AltKey,
		&i.Title,
		&i.Artist,
		&i.Genre,
		&i.Bpm,
		&i.ImageUrl,
		&i.Version,
		&i.IsUtage,
		&i.IsAvailable,
		&i.ReleaseDate,
		&i.DeleteDate,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getAllSongs = `-- name: GetAllSongs :many
select
    songs.song_id,
    songs.alt_key,
    songs.title,
    songs.artist,
    songs.genre,
    songs.bpm,
    songs.image_url,
    songs.version,
    songs.is_utage,
    songs.is_available,
    songs.release_date,
    songs.delete_date,
    coalesce(
        (
            select
                json_agg(
                    jsonb_build_object(
                        'beatmap_id', beatmaps.beatmap_id,
                        'difficulty', beatmaps.difficulty,
                        'level', beatmaps.level,
                        'internal_level', beatmaps.internal_level,
                        'type', beatmaps.type,
                        'total_notes', beatmaps.total_notes,
                        'tap', beatmaps.tap,
                        'hold', beatmaps.hold,
                        'slide', beatmaps.slide,
                        'touch', beatmaps.touch,
                        'break', beatmaps.break,
                        'note_designer', beatmaps.note_designer,
                        'max_dx_score', beatmaps.max_dx_score
                    )
                )
            from beatmaps
            where beatmaps.song_id = songs.song_id
        ),
        '[]'
    ) as beatmaps
from songs
order by songs.release_date desc
`

type GetAllSongsRow struct {
	SongID      uuid.UUID   `json:"songID"`
	AltKey      string      `json:"altKey"`
	Title       string      `json:"title"`
	Artist      string      `json:"artist"`
	Genre       string      `json:"genre"`
	Bpm         string      `json:"bpm"`
	ImageUrl    string      `json:"imageUrl"`
	Version     string      `json:"version"`
	IsUtage     bool        `json:"isUtage"`
	IsAvailable bool        `json:"isAvailable"`
	ReleaseDate pgtype.Date `json:"releaseDate"`
	DeleteDate  pgtype.Date `json:"deleteDate"`
	Beatmaps    interface{} `json:"beatmaps"`
}

func (q *Queries) GetAllSongs(ctx context.Context) ([]GetAllSongsRow, error) {
	rows, err := q.db.Query(ctx, getAllSongs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSongsRow
	for rows.Next() {
		var i GetAllSongsRow
		if err := rows.Scan(
			&i.SongID,
			&i.AltKey,
			&i.Title,
			&i.Artist,
			&i.Genre,
			&i.Bpm,
			&i.ImageUrl,
			&i.Version,
			&i.IsUtage,
			&i.IsAvailable,
			&i.ReleaseDate,
			&i.DeleteDate,
			&i.Beatmaps,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSongByAltKey = `-- name: GetSongByAltKey :one
select
    song_id,
    alt_key,
    title,
    artist,
    genre,
    bpm,
    image_url,
    version,
    is_utage,
    is_available,
    release_date,
    delete_date,
    updated_at,
    created_at
from songs
where alt_key = $1
`

func (q *Queries) GetSongByAltKey(ctx context.Context, altKey string) (Song, error) {
	row := q.db.QueryRow(ctx, getSongByAltKey, altKey)
	var i Song
	err := row.Scan(
		&i.SongID,
		&i.AltKey,
		&i.Title,
		&i.Artist,
		&i.Genre,
		&i.Bpm,
		&i.ImageUrl,
		&i.Version,
		&i.IsUtage,
		&i.IsAvailable,
		&i.ReleaseDate,
		&i.DeleteDate,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSongByID = `-- name: GetSongByID :one
select
    songs.song_id,
    songs.alt_key,
    songs.title,
    songs.artist,
    songs.genre,
    songs.bpm,
    songs.image_url,
    songs.version,
    songs.is_utage,
    songs.is_available,
    songs.release_date,
    songs.delete_date,
    coalesce(
        (
            select
                json_agg(
                    jsonb_build_object(
                        'beatmapID', beatmaps.beatmap_id,
                        'difficulty', beatmaps.difficulty,
                        'level', beatmaps.level,
                        'internalLevel', beatmaps.internal_level,
                        'type', beatmaps.type,
                        'totalNotes', beatmaps.total_notes,
                        'tap', beatmaps.tap,
                        'hold', beatmaps.hold,
                        'slide', beatmaps.slide,
                        'touch', beatmaps.touch,
                        'break', beatmaps.break,
                        'noteDesigner', beatmaps.note_designer,
                        'maxDxScore', beatmaps.max_dx_score
                    )
                )
            from beatmaps
            where beatmaps.song_id = songs.song_id
        ),
        '[]'
    ) as beatmaps
from songs
where songs.song_id = $1
`

type GetSongByIDRow struct {
	SongID      uuid.UUID   `json:"songID"`
	AltKey      string      `json:"altKey"`
	Title       string      `json:"title"`
	Artist      string      `json:"artist"`
	Genre       string      `json:"genre"`
	Bpm         string      `json:"bpm"`
	ImageUrl    string      `json:"imageUrl"`
	Version     string      `json:"version"`
	IsUtage     bool        `json:"isUtage"`
	IsAvailable bool        `json:"isAvailable"`
	ReleaseDate pgtype.Date `json:"releaseDate"`
	DeleteDate  pgtype.Date `json:"deleteDate"`
	Beatmaps    interface{} `json:"beatmaps"`
}

func (q *Queries) GetSongByID(ctx context.Context, songID uuid.UUID) (GetSongByIDRow, error) {
	row := q.db.QueryRow(ctx, getSongByID, songID)
	var i GetSongByIDRow
	err := row.Scan(
		&i.SongID,
		&i.AltKey,
		&i.Title,
		&i.Artist,
		&i.Genre,
		&i.Bpm,
		&i.ImageUrl,
		&i.Version,
		&i.IsUtage,
		&i.IsAvailable,
		&i.ReleaseDate,
		&i.DeleteDate,
		&i.Beatmaps,
	)
	return i, err
}

const getSongByTitleAndArtist = `-- name: GetSongByTitleAndArtist :one
select
    song_id,
    alt_key,
    title,
    artist,
    genre,
    bpm,
    image_url,
    version,
    is_utage,
    is_available,
    release_date,
    delete_date,
    updated_at,
    created_at
from songs
where title = $1 and artist = $2
`

type GetSongByTitleAndArtistParams struct {
	Title  string `json:"title"`
	Artist string `json:"artist"`
}

func (q *Queries) GetSongByTitleAndArtist(ctx context.Context, arg GetSongByTitleAndArtistParams) (Song, error) {
	row := q.db.QueryRow(ctx, getSongByTitleAndArtist, arg.Title, arg.Artist)
	var i Song
	err := row.Scan(
		&i.SongID,
		&i.AltKey,
		&i.Title,
		&i.Artist,
		&i.Genre,
		&i.Bpm,
		&i.ImageUrl,
		&i.Version,
		&i.IsUtage,
		&i.IsAvailable,
		&i.ReleaseDate,
		&i.DeleteDate,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSongsByTitle = `-- name: GetSongsByTitle :many
select
    song_id,
    alt_key,
    title,
    artist,
    genre,
    bpm,
    image_url,
    version,
    is_utage,
    is_available,
    release_date,
    delete_date,
    updated_at,
    created_at
from songs
where title = $1
`

func (q *Queries) GetSongsByTitle(ctx context.Context, title string) ([]Song, error) {
	rows, err := q.db.Query(ctx, getSongsByTitle, title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Song
	for rows.Next() {
		var i Song
		if err := rows.Scan(
			&i.SongID,
			&i.AltKey,
			&i.Title,
			&i.Artist,
			&i.Genre,
			&i.Bpm,
			&i.ImageUrl,
			&i.Version,
			&i.IsUtage,
			&i.IsAvailable,
			&i.ReleaseDate,
			&i.DeleteDate,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSong = `-- name: UpdateSong :one
update songs
set
    alt_key = $2,
    title = $1,
    artist = $3,
    genre = $4,
    bpm = $5,
    image_url = $6,
    version = $7,
    is_utage = $8,
    is_available = $9,
    release_date = $10,
    delete_date = $11,
    updated_at = now()
where song_id = $12
returning
    song_id,
    alt_key,
    title,
    artist,
    genre,
    bpm,
    image_url,
    version,
    is_utage,
    is_available,
    release_date,
    delete_date,
    updated_at,
    created_at
`

type UpdateSongParams struct {
	Title       string      `json:"title"`
	AltKey      string      `json:"altKey"`
	Artist      string      `json:"artist"`
	Genre       string      `json:"genre"`
	Bpm         string      `json:"bpm"`
	ImageUrl    string      `json:"imageUrl"`
	Version     string      `json:"version"`
	IsUtage     bool        `json:"isUtage"`
	IsAvailable bool        `json:"isAvailable"`
	ReleaseDate pgtype.Date `json:"releaseDate"`
	DeleteDate  pgtype.Date `json:"deleteDate"`
	SongID      uuid.UUID   `json:"songID"`
}

func (q *Queries) UpdateSong(ctx context.Context, arg UpdateSongParams) (Song, error) {
	row := q.db.QueryRow(ctx, updateSong,
		arg.Title,
		arg.AltKey,
		arg.Artist,
		arg.Genre,
		arg.Bpm,
		arg.ImageUrl,
		arg.Version,
		arg.IsUtage,
		arg.IsAvailable,
		arg.ReleaseDate,
		arg.DeleteDate,
		arg.SongID,
	)
	var i Song
	err := row.Scan(
		&i.SongID,
		&i.AltKey,
		&i.Title,
		&i.Artist,
		&i.Genre,
		&i.Bpm,
		&i.ImageUrl,
		&i.Version,
		&i.IsUtage,
		&i.IsAvailable,
		&i.ReleaseDate,
		&i.DeleteDate,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
