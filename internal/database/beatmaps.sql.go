// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: beatmaps.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createBeatmap = `-- name: CreateBeatmap :one
insert into beatmaps (
    beatmap_id,
    song_id,
    difficulty,
    level,
    internal_level,
    type,
    total_notes,
    tap,
    hold,
    slide,
    touch,
    break,
    note_designer,
    max_dx_score,
    is_valid,
    updated_at,
    created_at
)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, now(), now())
returning
    beatmap_id,
    song_id,
    difficulty,
    level,
    internal_level,
    type,
    total_notes,
    tap,
    hold,
    slide,
    touch,
    break,
    note_designer,
    max_dx_score,
    is_valid,
    updated_at,
    created_at
`

type CreateBeatmapParams struct {
	BeatmapID     uuid.UUID
	SongID        uuid.UUID
	Difficulty    string
	Level         string
	InternalLevel pgtype.Numeric
	Type          string
	TotalNotes    int32
	Tap           int32
	Hold          int32
	Slide         int32
	Touch         int32
	Break         int32
	NoteDesigner  string
	MaxDxScore    int32
	IsValid       bool
}

func (q *Queries) CreateBeatmap(ctx context.Context, arg CreateBeatmapParams) (Beatmap, error) {
	row := q.db.QueryRow(ctx, createBeatmap,
		arg.BeatmapID,
		arg.SongID,
		arg.Difficulty,
		arg.Level,
		arg.InternalLevel,
		arg.Type,
		arg.TotalNotes,
		arg.Tap,
		arg.Hold,
		arg.Slide,
		arg.Touch,
		arg.Break,
		arg.NoteDesigner,
		arg.MaxDxScore,
		arg.IsValid,
	)
	var i Beatmap
	err := row.Scan(
		&i.BeatmapID,
		&i.SongID,
		&i.Difficulty,
		&i.Level,
		&i.InternalLevel,
		&i.Type,
		&i.TotalNotes,
		&i.Tap,
		&i.Hold,
		&i.Slide,
		&i.Touch,
		&i.Break,
		&i.NoteDesigner,
		&i.MaxDxScore,
		&i.IsValid,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getAllBeatmaps = `-- name: GetAllBeatmaps :many
select
    beatmap_id,
    song_id,
    difficulty,
    level,
    internal_level,
    type,
    total_notes,
    tap,
    hold,
    slide,
    touch,
    break,
    note_designer,
    max_dx_score,
    is_valid,
    updated_at,
    created_at
from beatmaps
`

func (q *Queries) GetAllBeatmaps(ctx context.Context) ([]Beatmap, error) {
	rows, err := q.db.Query(ctx, getAllBeatmaps)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Beatmap
	for rows.Next() {
		var i Beatmap
		if err := rows.Scan(
			&i.BeatmapID,
			&i.SongID,
			&i.Difficulty,
			&i.Level,
			&i.InternalLevel,
			&i.Type,
			&i.TotalNotes,
			&i.Tap,
			&i.Hold,
			&i.Slide,
			&i.Touch,
			&i.Break,
			&i.NoteDesigner,
			&i.MaxDxScore,
			&i.IsValid,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBeatmapByBeatmapID = `-- name: GetBeatmapByBeatmapID :one
select
    beatmap_id,
    song_id,
    difficulty,
    level,
    internal_level,
    type,
    total_notes,
    tap,
    hold,
    slide,
    touch,
    break,
    note_designer,
    max_dx_score,
    is_valid,
    updated_at,
    created_at
from beatmaps
where beatmap_id = $1
`

func (q *Queries) GetBeatmapByBeatmapID(ctx context.Context, beatmapID uuid.UUID) (Beatmap, error) {
	row := q.db.QueryRow(ctx, getBeatmapByBeatmapID, beatmapID)
	var i Beatmap
	err := row.Scan(
		&i.BeatmapID,
		&i.SongID,
		&i.Difficulty,
		&i.Level,
		&i.InternalLevel,
		&i.Type,
		&i.TotalNotes,
		&i.Tap,
		&i.Hold,
		&i.Slide,
		&i.Touch,
		&i.Break,
		&i.NoteDesigner,
		&i.MaxDxScore,
		&i.IsValid,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getBeatmapBySongID = `-- name: GetBeatmapBySongID :one
select
    beatmap_id,
    song_id,
    difficulty,
    level,
    internal_level,
    type,
    total_notes,
    tap,
    hold,
    slide,
    touch,
    break,
    note_designer,
    max_dx_score,
    is_valid,
    updated_at,
    created_at
from beatmaps
where song_id = $1
`

func (q *Queries) GetBeatmapBySongID(ctx context.Context, songID uuid.UUID) (Beatmap, error) {
	row := q.db.QueryRow(ctx, getBeatmapBySongID, songID)
	var i Beatmap
	err := row.Scan(
		&i.BeatmapID,
		&i.SongID,
		&i.Difficulty,
		&i.Level,
		&i.InternalLevel,
		&i.Type,
		&i.TotalNotes,
		&i.Tap,
		&i.Hold,
		&i.Slide,
		&i.Touch,
		&i.Break,
		&i.NoteDesigner,
		&i.MaxDxScore,
		&i.IsValid,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
